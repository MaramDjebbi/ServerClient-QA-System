# ServerClient-QA-System

A client/server communication system with a random number request and response protocol using named pipes and SIGUSR1 signals.

## Introduction

This report presents a client-server communication system. The server is waiting for customer questions via a named pipe (fifo1). Each question contains a request to send 'n' numbers randomly generated by the server. The customer also sends its identifier to be notified by the server via a signal SIGUSR1. A protocol is established to ensure that each customer receives their answers correctly. The client signals to the server when it has finished reading its answers.

## Components

### serveur.c

The code in this file implements a server that communicates with a client via named pipes.

- It creates two named pipes for communication with clients.
- Initializes a random number generator.
- Installs signal handlers: one to react to the signal SIGUSR1 (used to wake up the client), and the other to manage the end of the server in response to other signals.
- The server enters a loop where it loads and processes questions from clients.
- It generates a random response and sends it to the client. It sends a signal to the client to wake them up.
- It waits for a signal to continue.
- If reading the question fails or takes too long, the server waits briefly.

### client.c

The code in this file involves a client communicating with a server via named pipes.

- It opens named pipes for communication.
- Initializes a random number generator.
- Installs a signal handler to react to the SIGUSR1 signal.
- Generates a random question, sends it to the server, and waits for a response.
- Reads the response from the server, sends a signal to the server, and processes the response.
- Closes the pipes and ends the program.

### serv_cli_fifo.h

This file provides headers for essential system files, such as `<stdio.h>`, `<stdlib.h>`, `<unistd.h>`, `<sys/stat.h>`, `<sys/types.h>`, `<fcntl.h>`, `<errno.h>`, `<time.h>`, and `<signal.h>`. It also defines shared constants and macros between clients and servers, such as `NMAX` to define a maximum size, as well as the named pipe paths (`fifo1`, `fifo2`, etc.) to establish communication between processes. Additionally, this code includes the definition of data structures to represent a question and an answer, allowing the organization and transmission of this information between the different components of the program.

### Handlers_Serv.h

This file contains two signal management functions for the server:

- `hand_reveil(int sig)`: This function reacts to the reception of the signal SIGUSR1. It is used to signal to the server that a client wants to interact with it.
- `end_server(int sig)`: This function reacts to the reception of any signal. It is designed to manage the termination of the server in response to the reception of any signal.

### Handlers_cli.h

This file contains a function designed to wake the client in response to receiving the SIGUSR1 signal. It serves as a mechanism to notify and wake up the client following an event triggered by sending this specific signal.

### Makefile

The "Makefile" is designed to compile client and server source code, create the `fifo` directory, provide targets to run the server and client in separate GNOME Terminal windows, and include a clean target to clean the generated files and directory. The `sleep` command in the "run_client" target introduces a 5-second delay after running the client program before closing the terminal window.

## How to Run the System

To run the client-server communication system, follow these steps:
- Open a terminal.
- Navigate to the directory containing your source code and the Makefile.

1. **Compile the Code:**
   
   - Compile the client and server programs by running the following command:

     ```bash
     make all
     ```

   This will compile the client and server executables and create the necessary `fifo` directory.

2. **Start the Server:**
   - To run the server, execute the following command:

     ```bash
     make run_server
     ```

   This will open a new GNOME Terminal window with the server running.

3. **Start a Client:**
   - To run a client, execute the following command:

     ```bash
     make run_client
     ```

   This will open a new GNOME Terminal window with the client running. The client will send a request to the server and wait for a response. After a 5-second delay, the terminal will close.

4. **Interaction and Testing:**
   - Observe the interaction between the client and server in their respective terminal windows.
   - You can run multiple client instances to test the system's concurrent communication capabilities.

5. **Clean Up:**
   - To clean up the generated files and the `fifo` directory, use the following command:

     ```bash
     make clean
     ```

   This will remove the client and server executables, as well as the `fifo` directory.

That's it! You now have the client-server system up and running, allowing communication between the server and clients via named pipes and SIGUSR1 signals.

